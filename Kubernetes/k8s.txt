#Cluster Architecture

Master Nodes
Manages ,Plans schedule monitor Nodes

Control plane contoller

Etcd
#store data

K8s Scheduler
#schedules pods


#Kube Api server


Docker Engine

Kubelet is the main .its an agent on all nodes listen to kube api server for any instructions 

Worker Nodes
Host Applications as Containers

#Kube Proxy
For network service
Ensures rules are in place


##############################################################################################
##############################################################################################

# Labels and selector 

For identification purpose

pod-definetion.yaml

kubectl get pods --selector app=App1

Implemented Shared Library to share and reuse code across 35+ CI pipeline configurations.
Hand on experience to manage the entire build and release activity across multiple environments and infrastructure.


Enveloped in mission-critical production deployment with applying best practices of SRE principles.
Troubleshoot the application logs to get the issue on the application side.


Taint and toleration

Kubectl taint nodes node-name key=value: taint-effect
No schedule prefernoschedule Noexecute
Kubectl taint nodes node1 app=blue:Noschedule

kubectl describe node kubemaster |grep Taint

kubectl describe node node01 |grep Taint

kubectl taint nodes node01 spray=mortein:NoSchedule

3node selector to Define a particular node to serve the   

kubectl label nodes node01 color=blue


kubectl create deployment blue --image=nginx --replicas=3

## Node affinity : Node affinity is a set of rules used by the scheduler to determine where a pod can be placed.

##The rules are defined using custom labels on nodes and label selectors specified in pods.
## Node affinity allows a pod to specify an affinity (or anti-affinity) towards a group of nodes it can be placed on.

Scale

kubectl create -f replicaset-defenition.yml

kubectl scale --relicas=6 -f replicaset-definition.yml

kubectl scale --replicas=6 replicaset myapp-replicaset

kubectl get replicaset

kubectl delete relicaset myapp-replicaset

kubectl replace -f replicaset-defenition.yml

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: Replicaset-1
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx


apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: Replicaset-1
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx



kubectl edit replicaset new-replica-set

kubectl scale rs new-replica-set --replicas=2

Deployemnts kubernetes deployment

upgrade the underlying instance
rolling update
undo chnages 
resume chnages as required.

Create an NGINX Pod

kubectl run nginx --image=nginx

Generate POD Manifest YAML file (-o yaml). Don’t create it(–dry-run)

kubectl run nginx --image=nginx --dry-run=client -o yaml

Create a deployment

kubectl create deployment --image=nginx nginx

Generate Deployment YAML file (-o yaml). Don’t create it(–dry-run)

kubectl create deployment --image=nginx nginx --dry-run=client -o yaml

Generate Deployment YAML file (-o yaml). Don’t create it(–dry-run) with 4 Replicas (–replicas=4)

kubectl create deployment --image=nginx nginx --dry-run=client -o yaml > nginx-deployment.yaml

Save it to a file, make necessary changes to the file (for example, adding more replicas) and then create the deployment.

kubectl create -f nginx-deployment.yaml

OR

In k8s version 1.19+, we can specify the –replicas option to create a deployment with 4 replicas.

kubectl create deployment --image=nginx nginx --replicas=4 --dry-run=client -o yaml > nginx-deployment.yaml


Namespaces

inside a house
to isolate from different 
multiple container list of resource


KUBECTL GET Pods

kubectl get pods --namespace=kube-system
kubectl config set-context $(kubectl config currrent-context) --namespace=dev

kubectl get pods --namespace=research

kubectl get pods --n

kubectl run redis --image=redis -n finance

##services

connect application within Applications
Group of pods 
##External connect

 Kubernetes object

 relicaset
 pods
 service
 listen to port on a node and forward request 

 nodeport :service which listen port on a node 
 and forward traffic to pods.

Services Typoes

Node port
makes as internal POD accesable on a port on the Node.

Cluster IP creates a virtual IP inside the cluster to enable communication between

service-defenition port
selector

pod-definition file

kubectl get services

kubectl describe services




Tripura

Back to Course
Certified Kubernetes Administrator (CKA)
18% Complete
49/269 Steps
Introduction
4 Topics
Core Concepts
37 Topics
Core Concepts Section Introduction (00:31)
Cluster Architecture (08:48)
ETCD for Beginners (03:03)
ETCD in Kubernetes (03:17)
ETCD - Commands (Optional)
Kube API Server (04:51)
Kube Controller Manager (04:15)
Kube Scheduler (03:53)
Kubelet (01:42)
Kube Proxy (03:41)
PODs (09:13)
Practice Test Introduction (05:45)
Practice Test - PODs
Solution - Pods (optional) (07:39)
ReplicaSets (16:09)
Practice Test - ReplicaSets
Solution - ReplicaSets (optional) (07:46)
Join our Slack Channel
Deployments (04:26)
Certification Tip!
Practice Tests - Deployments
Solution: Deployment(optional) (05:08)
Namespaces (08:23)
Practice Test Namespaces
Solution: Namespaces (optional) (05:03)
Services (13:50)
Services Cluster IP (04:02)
Services - Loadbalancer (03:42)
Practice Test Services
Solution: Services (optional) (05:01)
Imperative vs Declarative (13:06)
Certification Tips - Imperative Commands with Kubectl
Practice Test - Imperative Commands
Solution: Imperative Commands (optional) (07:52)
Kubectl Apply Command (04:38)
Download Presentation Deck for this section 1
Feedback
Scheduling
32 Topics
Logging & Monitoring
8 Topics
Application Lifecycle Management
27 Topics
Cluster Maintenance
18 Topics
Security
35 Topics
Storage
15 Topics
Networking
38 Topics
Design and Install a Kubernetes Cluster
6 Topics
Install "Kubernetes the kubeadm way"
6 Topics
Troubleshooting
14 Topics
Other Topics
4 Topics
Lightning Labs
2 Topics
Mock Exams
8 Topics
CORE CONCEPTS > CERTIFICATION TIPS – IMPERATIVE COMMANDS WITH KUBECTL
In Progress
←Previous
Next→
Certification Tips – Imperative Commands with Kubectl
While you would be working mostly the declarative way – using definition files, imperative commands can help in getting one time tasks done quickly, as well as generate a definition template easily. This would help save considerable amount of time during your exams.

Before we begin, familiarize with the two options that can come in handy while working with the below commands:

--dry-run: By default as soon as the command is run, the resource will be created. If you simply want to test your command , use the --dry-run=client option. This will not create the resource, instead, tell you whether the resource can be created and if your command is right.

-o yaml: This will output the resource definition in YAML format on screen.

 

Use the above two in combination to generate a resource definition file quickly, that you can then modify and create resources as required, instead of creating the files from scratch.

 

POD
Create an NGINX Pod

kubectl run nginx --image=nginx

 

Generate POD Manifest YAML file (-o yaml). Don’t create it(–dry-run)

kubectl run nginx --image=nginx --dry-run=client -o yaml

 

Deployment
Create a deployment

kubectl create deployment --image=nginx nginx

 

Generate Deployment YAML file (-o yaml). Don’t create it(–dry-run)

kubectl create deployment --image=nginx nginx --dry-run=client -o yaml

 

Generate Deployment with 4 Replicas

kubectl create deployment nginx --image=nginx --replicas=4

 

You can also scale a deployment using the kubectl scale command.

kubectl scale deployment nginx --replicas=4 

Another way to do this is to save the YAML definition to a file and modify

kubectl create deployment nginx --image=nginx --dry-run=client -o yaml > nginx-deployment.yaml

 

You can then update the YAML file with the replicas or any other field before creating the deployment.

 

Service
Create a Service named redis-service of type ClusterIP to expose pod redis on port 6379

kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml

(This will automatically use the pod’s labels as selectors)

Or

kubectl create service clusterip redis --tcp=6379:6379 --dry-run=client -o yaml (This will not use the pods labels as selectors, instead it will assume selectors as app=redis. You cannot pass in selectors as an option. So it does not work very well if your pod has a different label set. So generate the file and modify the selectors before creating the service)

 

Create a Service named nginx of type NodePort to expose pod nginx’s port 80 on port 30080 on the nodes:

kubectl expose pod nginx --type=NodePort --port=80 --name=nginx-service --dry-run=client -o yaml

(This will automatically use the pod’s labels as selectors, but you cannot specify the node port. You have to generate a definition file and then add the node port in manually before creating the service with the pod.)

Or

kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml

(This will not use the pods labels as selectors)

Both the above commands have their own challenges. While one of it cannot accept a selector the other cannot accept a node port. I would recommend going with the `kubectl expose` command. If you need to specify a node port, generate a definition file using the same command and manually input the nodeport before creating the service.

Reference:
https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands

https://kubernetes.io/docs/reference/kubectl/conventions/

